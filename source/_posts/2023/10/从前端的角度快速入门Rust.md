---
title: 从前端的角度快速入门 Rust
date: 2023-10-17 11:44:43
tags:
  - rust
---

# 前言

Rust 是一门系统编程语言，与 JavaScript 不一样的是，它是一门编译型语言，类比 C++。

目前有很多前端工具是基于 Rust 写的，暴露的 API 则通过 [napi-rs](https://napi.rs/cn) 转换成 nodejs 模块，例如 [SWC](https://swc.rs/) 。

一些新的工程化工具，例如字节的 [Rspack](https://www.rspack.dev/)；媲美 Electron 的跨平台桌面开发框架 [Tauri](https://tauri.app/)。

可以说很多对性能或内存安全的应用，都可以用 Rust 重写。对于前端开发者来说，如果想熟悉一门编译型语言，Rust 是一个很好的选择。

关于怎么安装 Rust ，请直接浏览[官网安装文档](https://www.rust-lang.org/zh-CN/learn/get-started) 

# Hello World

安装好之后，在终端内输入以下命令可以查看对应版本

```bash
# 查看 rust 版本
rustc --version
# 查看 cargo 版本
cargo --version
```

> cargo 是 Rust 官方的包管理工具，类似 nodejs 里面的 npm，yarn 这些

随便选一个目录创建一个 hello.rs 文件，打开文件写入如下代码：

```rs
fn main() {
    println!("Hello, world!");
}
```

在终端内进入该文件所在目录，输入 `rustc hello.rs` 进行编译，执行完毕后在相同目录下会出现一个 index 可执行文件（Windows下带后缀 .exe），然后在终端内执行 `./hello` （Windows下是 `./hello.exe`），终端内输出 “Hello, world!”

从上面的代码中，我们可以看出：
1、Rust 使用 `fn` 作为函数声明的关键字，如 JavaScript 里面用的是 `function`
2、Rust 的入口函数是 `main` 函数
3、`println!` 是一个终端输出函数，接收字符串，在执行时输出
4、Rust 代码需要编译后才能执行

> println 后面有个 `!` 号，这表示其是一个宏函数，后续会说明，可以先把它类比 JavaScript 的全局函数

# 通用编程概念

这一节介绍所有编程语言里面最基础通用的概念，Rust 也是，核心部分很多语言都有共同点，这些都是基础内容。

## 变量与常量

### 局部变量

Rust 中声明变量使用 `let` 关键字，例如：

```rs
let a = 1;
let s = "hello world";
```

与 JavaScript 不同的是，let 声明的变量，不能重新赋值，这跟 Rust 的所有权限制有关，后续会说明，记住这一点就行，例如下面这段代码会报错：

```rs
let a = 1;
a = 2; // 报错
```
![](https://blog-1257256187.cos.ap-chengdu.myqcloud.com/blog-imgs/202310171511621.png?imageMogr2/format/webp)

从报错信息的提示文案中 “help: consider making this binding mutable: `mut a`”，可以看出，它提示我们可以加个 `mut`，这涉及到另外个关键字了。

在 Rust 里面，变量默认是不可变的，如果要可变，需要加 `mut`，例如：

```rs
let mut a = 1;
println!("a = {}", a);
a = 2;
println!("a = {}", a);
```

> Rust 中声明的变量必须得用到，例如上面代码，如果去掉第二行，虽然不会报语法错误，但是会报警告，因为在将 a 赋值为 2 之前，a 并没有被用到，所以 Rust 编译器会给出警告： “warning: value assigned to `a` is never read”。

### 全局变量

全局变量的生命周期是整个程序，从启动到退出，它占用的内存空间是固定的，不会在执行过程中被回收。全局变量的声明使用 `static`，使用全局变量声明时，必须显式标明变量类型，例如：

```rs
static A: i32 = 1;
static mut N: i32 = 5;
```

可以看出，Rust 的变量标明跟 TypeScript 类似，都是使用冒号 `:` 隔开，后面跟类型。

### 常量

常量的生命周期也是整个程序，用 `const` 关键字声明，与 `static` （不可变变量）不同的是，编译器并不一定会为其分配内存空间，在编译过程中，可能会被内联优化，类似 C 语言的宏定义：

```rs
const N: i32 = 5;
```

> 不论是 `static` 声明的变量还是 `const` 声明的常量，都建议使用大写蛇形命名，形如 `SCREAMING_SNAKE_CASE`，这是 Rust 的规范建议。局部变量、函数和方法，都建议使用小写蛇形命名，形如 `snake_case`。如图：
> ![](https://blog-1257256187.cos.ap-chengdu.myqcloud.com/blog-imgs/202310171546009.png?imageMogr2/format/webp)

## 注释

```rs
/// 外部注释
mod test {
    //! 包/模块级别的注释
    
    /** 外部块文档注释 */
    pub fn foo() {
        /*! 内部块文档注释 */

        // 行注释
        /* 块注释 */
    }
}
```

注释内容支持 markdown 语法，使用 `cargo doc` 可以生成 HTML 文档

> 这里的 `mod` 是包管理和模块的关键字，后续章节说明

## 基础数据类型

### 数值类型

整数类型：

|长度	|有符号类型	|无符号类型|
|---|---|---|
|8 位	|i8	|u8 |
|16 位	|i16	|u16|
|32 位	|i32	|u32|
|64 位	|i64	|u64|
|128 位	|i128	|u128|
|视架构而定	|isize	|usize|

> isize 与 usize 取决于当前执行程序的 CPU 类型，如果是32位的，则等同于i32和ui32，类似的如果是64位，则等同于i64和ui64。像`let i = 1;` 这种类型推导，Rust整型会默认使用 `i32` 类型。

浮点数类型： `f32` 和 `f64` ，Rust 的浮点数类型跟 JavaScript 一样，在处理 0.2 + 0.1 的时候并不等于 0.3，因为浮点数在内存中是以二进制存储的

> 整型溢出，在 Debug 模式下 Rust 会崩溃（panic）。但是 Release 模式下则默认采取补码循环溢出处理，例如在 `u8` 类型下，256 变成 0，257 变成 1，以此类推。
> 要显式处理溢出，可以通过标准库提供的针对原始数值类型的下列方法处理：
> - `wrapping_*` 所有模式下，都按照补码循环溢出处理
> - `checked_*` 发生溢出时，返回 `None` 值
> - `overflowing_*` 发生溢出时，返回 `(n, is_over)` 元组，其中 `n` 为补码循环溢出后的值，`is_over` 是布尔值，表示是否溢出
> - `saturating_*` 发生溢出时，返回当前类型的最大值或最小值
> 上述的 * 指代 `add`、`sub`、`mul`、`div`等命名

### 布尔类型

`bool` 类型，只有两个值 `true` 和 `false`，布尔值占用内存大小为 1 个字节。

### 字符类型

`char` 字符类型使用单引号，与 C 语言不同的是，Rust中所有的 `Unicode` 值都可以作为字符，包括单个中文、日文、Emoji表情符号等，都是合法字符，例如：

```rs
fn main() {
    let c = 'z';
    let z = 'ℤ';
    let g = '国';
    let heart_eyed_cat = '😻';
}
```

> 一个 Unicode 字符占用 4 个字节，因此字符类型的内存占用为 4 个字节
> ```rs
> fn main() {
>    let x: char = 'z';
>    println!("字符'z'占用了{}字节的内存大小",std::mem::size_of_val(&x));
> }
> ```
> 

### 单元类型

`()` 类型，表示空元组，即没有任何元素的元组

> 例如上面字符类型章节的代码里面，`main` 方法没有返回值，其实就是默认返回值为 `()` ，这种也叫做 `发散函数( diverge function)`，另外也可以用 `()` 作为 map 的值，表示不关注具体的值，只关注 `key`。
> 在一些程序中，会经常看到处理 `Result` 时用 `Ok(())` 作为值，表示处理成功，不关心返回值，后续错误处理章节说明。

### 字符串

`str` 字符串字面量类型使用双引号，**与字符不同的是，字符串使用的是 UTF-8 编码，也就是字符串中的字符所占字节数是变化的（1~4）**，`str` 类型是硬编码进可执行文件，无法被修改，在使用变量指向时，通常是指向其

```rs
fn main() {
    let s: &str = "Hello😻";
    println!("字符串\"{}\"，其类型大小为 {} 字节， 值大小为 {} 字节", s, std::mem::size_of_val(&s), std::mem::size_of_val(s)); // 字符串"Hello😻"，其类型大小为 16 字节， 值大小为 9 字节
}
```

从上述代码中可以看出，s 并不是 `str`，而是 `&str` 类型，也就是字符串切片。这是因为，str 字符串字面量是直接硬编码写入的，所以绑定变量时，是直接将 `str` 的地址返回给变量 s，如果有两个相同的字符串字面量，绑定不同的变量名，其地址是相同的。

下文的集合章节里，会进行详细说明。

## 运算符

基本上，JavaScript 里面有的运算符，Rust 都支持。

**数值运算：** `+`、`-`、`*`、`/`、`%`，以及 `+=`、`-=`、`*=`、`/=`、`%=`，以及按位计算符号：`&`、`&=`、`|`、`|=`、`^`、`^=`、`>>`、`>>=`、 `<<`、`<<=`

**逻辑运算：** `&&`、`||`、`!`，`<`、`<=`、`>`、`>=`、`!=`

**其他运算符**：

| 符号 | 解释 | 例子|
|---|---|---|
| ! | 宏展开 | `println!()` |
| & | 借用 |  |
| * | 解引用 |  |
| * | 裸指针 | |
| -> | 函数与闭包，返回类型 | |
| . | 成员访问 |  |
| .. | 右半开区间 |  |
| ..= | 右半闭区间 |  |
| : | 类型约束 | `let i: u8 = 10;` |
| ; | 语句结束符 | `println!();` |
| ; | 固定大小数组个数分隔符 | `let a: [i32; 5] = [1, 2, 3, 4, 5];` |
| ? | 错误传播 | |


> Rust 没有 `++` 和 `--` 这两个运算符。
> 字符串不支持 `+` 拼接，可以使用 `format!` 宏，后面会说明；

## 流程控制

### 表达式与语句

Rust 中的语句就是指通过 `;` 结尾的代码，而表达式，可以简单理解成某个运算，其有值返回，例如 `5 + 6` 就是个表达式，如下：

```rs
fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
```

代码中，`3` 和 `x + 1` 是个表达式；`{ let x = 3; x + 1 }` 也属于语句块表达式，其运算后值是 `x + 1` 也就是 4，赋值给变量 `y`。

> 注意，`x + 1` 不能以 `;` 结尾，否则其就是个语句，语句不会返回值，程序就会报错。所以一般的，在一些需要有返回值的函数内，可以直接在函数末尾使用表达式，而不需要写 `return` 关键字返回值。

### if - else 分支控制

Rust 的 if 与 JavaScript 不同在于，它不需要用括号括起来，例如：

```rs
if condition == true {
    // A...
} else {
    // B...
}
```

当然，也支持 if - else if 这种处理多重条件，例如：

```rs
if a == 1 {
    // A...
} else if a == 2  {
    // B...
} else {
    // C...
}
```

if 语句块是表达式，支持返回值赋值，例如：

```rs
fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!("The value of number is: {}", number); // 5
}
```

> 需注意的是，if 语句块返回值赋值的话，需要保证每个分支下的返回类型是一致的，如果不一致，会报错！


### 循环

**for in 循环**

for 循环是最常用的，例如：

```rs
fn main() {
    for i in 1..=5 {
        println!("{}", i); // 1, 2, 3, 4, 5
    }
}
```

跟 JavaScript 的 `for - in` 很像，`..=` 表示的是一个闭合区间，其可以理解成 `[1,2,3,4,5]` 的 `i32` 数组。

> 需要注意的是，for 循环时，是将集合的所有权进行了转移（`move`），所以一般情况下，集合需要通过引用（`&`）来获取，后续引用章节详细说明，先记住有这个注意点。而基本的数据类型`[i32; n]` 这种，已经实现了 `copy` 特征，所以不需要转移所有权。

那如果有一个数组，怎么获取其索引呢？如代码：

```rs
fn main() {
    let a = [4, 3, 2, 1];
    // `.iter()` 方法把 `a` 数组变成一个迭代器
    for (i, v) in a.iter().enumerate() {
        println!("第{}个元素是{}", i + 1, v);
    }
}
```

那就是遍历其迭代器，迭代器每次遍历返回的是一个元组，第一个值是索引，第二个值是值。

**while 循环**

跟 JavaScript 一模一样，例如：

```rs
fn main() {
    let mut n = 0;
    while n <= 5  {
        println!("{}!", n);
        n = n + 1;
    }
    println!(n);
}
```

**loop 循环**

Rust 特殊的循环关键字，后面跟一个语句块，组成 loop 表达式，块内死循环，除非通过 `break` 跳出循环，例如：

```rs
fn main() {
    let mut counter = 0;
    let result = loop {
        counter += 1;
        if counter == 10 {
            break counter * 2;
        }
    };
    println!("The result is {}", result);
}
```

在 Rust 中，`continue` 和 `break` 也是支持的，并且在 loop 表达式中，break 可以携带返回值

> 一般的循环，在 `while` 和 `for` 中建议使用 for 的方式，因为 for 通过迭代器选择，会避免运行时的边界索引检查，性能更好。而 `loop` 表达式，更适用于简单的循环需要返回值的情况。

## 函数

# cargo包管理工具


# Rust的特殊概念

## 所有权与借用

## 生命周期

## 智能指针

## 特征

# 集合

## 字符串与切片

字符串拼接

## 结构体与枚举

## 元组

## 数组


# 接口与泛型


# 错误处理


# 包管理与模块化


# 自动化测试


# 进阶内容

## 面向对象

## 并发

## 高级特征

## 高级函数与闭包

