---
title: 简述HTTP协议
date: 2020-05-05 20:17:26
tags:
---

# 简述HTTP协议与发展

## HTTP协议

在TCP/IP协议簇中，计算机网络分为四层，分别是：网络接口层，网际层，运输层，应用层。

其中：

IP协议——网际层

TCP协议——运输层

HTTP协议——应用层



HTTP全称Hyper Text Transfer Protocol（超文本传输协议），工作于“客户端-服务端”架构上，基于TCP连接来传递数据。

### 主要特点

- 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。
- 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。



## HTTPS协议

![img](https://blog-1257256187.cos.ap-chengdu.myqcloud.com/img/20200520123231.png)

如上图，左边是HTTP协议架构，右边是HTTPS协议，从图中知道`HTTPS = HTTP + SSL/TLS`。

引入HTTPS主要是为了保证通信安全，通信安全的四个基本特征是密性、完整性、身份认证和不可否认。SSL/TLS 是信息安全领域中的权威标准，采用多种先进的加密技术保证通信安全：

**机密性由对称加密AES保证，完整性由SHA384摘要算法保证，身份认证和不可否认由RSA非对称加密保证**



## HTTP/1.x

### HTTP/0.9

HTTP刚出来的时候，主要是用来传输文本，也只允许GET请求方式。感兴趣可以查阅相关资料。

> GET：发送一个请求来取得服务器上的某一资源

### HTTP/1.0

1、为了能够适应更多的场景，引入了HEAD、POST新请求方式。参考[POST提交数据方式](/browser/POST提交数据方式)

> HEAD：只请求页面的首部
>
> POST：向`URL`指定的资源提交数据或附加新的数据



2、为了传输数据不再局限文本，引入了请求头和响应头，它们以key-value对的形式存在。HTTP1.0的请求过程如下图：

![img](https://blog-1257256187.cos.ap-chengdu.myqcloud.com/img/20200519122021.png)



3、为了浏览器能够知晓服务端处理结果和状态，HTTP1.0引入了状态码。常见的状态码如下：

| 状态码 | 英文名                | 含义                                                         |
| ------ | --------------------- | ------------------------------------------------------------ |
| 100    | Continue              | 一般在发送`post`请求时，已发送了`http header`之后服务端将返回此信息，表示确认，之后发送具体参数信息 |
| 200    | OK                    | 正常返回信息                                                 |
| 201    | Created               | 请求成功并且服务器创建了新资源                               |
| 202    | Accepted              | 服务器已接受请求，但并未处理                                 |
| 301    | Moved Permanently     | 请求的资源被永久重定向                                       |
| 302    | Found                 | 临时性重定向                                                 |
| 304    | Not Modified          | 自上次请求后，请求的资源未更改                               |
| 400    | Bad Request           | 服务端无法理解的请求格式                                     |
| 401    | Unauthorized          | 请求未授权，需要认证                                         |
| 403    | Forbidden             | 禁止访问                                                     |
| 404    | Not Found             | 找不到如何与 `URI` 相匹配的资源                              |
| 500    | Internal Server Error | 服务端错误                                                   |
| 503    | Service Unavailable   | 服务端暂时无法处理请求，可能是过载或维护                     |



4、为了减轻服务器的压力，在 HTTP/1.0 中提供了缓存机制，用来缓存已经下载过的数据。主要由服务端返回的Expires头决定。

**缺点**：

- 每次HTTP通信过程都会进行一次TCP连接和断开。
- 缓存由Expires决定，若客户端与服务端时间有误差，会导致缓存命中误差

### HTTP/1.1

1、增加了PUT、OPTIONS、DELETE、TREACE、CONNECT请求方法。

> PUT：跟`POST`方法很像，也是想服务器提交数据。但是，它们之间有不同。`PUT`指定了资源在服务器上的位置，而`POST`没有
>
> OPTIONS：它用于获取当前`URL`所支持的方法。如果请求成功，会有一个`Allow`的头包含类似`“GET,POST”`这样的信息
>
> DELETE：删除服务器上的某资源
>
> TRACE：用于激发一个远程的，应用层的请求消息回路
>
> CONNECT：把请求连接转换到透明的`TCP/IP`通道



2、为了解决每次HTTP通信都建立TCP连接的资源损耗问题，引入长连接支持，支持管道化

 在请求头中，使用`connection: keep-alive`保持一条TCP通路不断开，在其中可以按顺序发起多次HTTP通信。浏览器一般会为一个站点开启最多6~8条TCP长连接通道，以实现并行的效果。



3、使用Cache-Control替代Expires，引入协商缓存机制

关于缓存的相关介绍，请参考[HTTP缓存](/browser/HTTP缓存)



4、为了方便传输大文件，允许响应数据分块，支持断点续传

断点续传的内容，请参考[浏览器上的大文件传输](/browser/浏览器上的大文件传输)

## HTTP/2.x

1、为了解决文本传输的限制，HTTP2采用**二进制编码传输**，引入流和帧的概念。

在HTTP1.x版本中，HTTP通信是通过ASCII文本进行的（图片等二进制文件是通过MIME转ASCII的），使用超文本传输的好处就是利于调试，但是不好的地方就是解析起来麻烦，二进制传输相比来说解析起来更高效。

HTTP2相当于把部分的TCP协议特性挪到了应用层，将原来的“Header + Body”的消息拆分到多个二进制帧里面，用"HEADERS"帧存放头数据、"DATA"帧存放实体数据。HTTP/2数据分帧后"Header+Body"的报文结构就完全消失了，协议看到的只是一个个的"碎片"，如图：

![img](https://blog-1257256187.cos.ap-chengdu.myqcloud.com/img/20200520111943.png)

但是这些帧的话都会携带一个标识码，用来标识其是哪一条消息的帧，这样服务端接收到之后可以将帧组合成消息，然后进行后续处理。



2、为了解决HTTP/1.1的队头堵塞问题，HTTP/2.x引入**多路复用技术**。

在HTTP/1.1中，是采用一条TCP连接上可以进行多个HTTP通信的方式，但是这种方式有个限制就是后一个请求必须等待前一个结束之后才可以进行，如果前一个因为某些原因阻塞了，就会影响后面的请求进行。

所以在HTTP/2中，因为有了帧的存在，HTTP /2 不再依赖 TCP 链接去实现多流并行了。其特点如下：

- 同域名下所有通信都在单个连接上完成；
- 单个连接可以承载任意数量的双向数据流；
- 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。

也因为这个特性，使网络传输性能有了大的提高：

- 消除了因多个 TCP 连接而带来的延时和内存消耗；
- 并行交错地发送多个请求，请求和响应之间互不影响；
- 在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。



3、为了解决HTTP头部信息过多，HTTP2采用了**Header压缩**。

HTTP/2并没有使用传统的压缩算法，而是开发了专门的"HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。具体如下：

- 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送；
- 首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新；
- 每个新的首部键-值对要么被追加到当前表的末尾，要么替换表中之前的值。

如下图两个请求，请求1发送了所有的头部字段，请求2则只需要发送差异数据，这样可以减少冗余数据，降低开销。

![img](https://blog-1257256187.cos.ap-chengdu.myqcloud.com/img/20200520114258.png)



4、引入**服务端推送技术**。

HTTP2还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求HTML的时候就提前把可能会用到的JS、CSS文件发给客户端，减少等待的延迟，这被称为"服务器推送"（ Server Push，也叫 Cache push）。

例如下图所示,服务端主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。

![](https://blog-1257256187.cos.ap-chengdu.myqcloud.com/img/20200520114726.png)

另外需要补充的是,服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行。



## 未来的HTTP——HTTP/3

先从一张图直观地来看HTTP的发展：

![img](https://blog-1257256187.cos.ap-chengdu.myqcloud.com/img/20200520115325)

可以看出，HTTP/3和之前的HTTP版本是完全不同的传输协议了，HTTP/3用的是UDP。

> 为什么使用UDP？
>
> 其实，HTTP/2并没有完全的解决“队头阻塞”问题！为什么这么说，因为HTTP/2的队头阻塞解决方案是在应用层，而传输层使用的TCP协议为了保证可靠传输，有丢包重传机制，其他的包必须等待这个丢失的包重新传输确认之后才可以继续传输。所以无论HTTP/2怎么设计都无法完全解决这个问题。HTTP/3将传输层协议换成了 UDP，因为 UDP 是无序的，包之间没有依赖关系，所以就从根本上解决了“队头阻塞”。

那，UDP是一个简单、不可靠的传输协议，只是对IP浅包装，HTTP/3怎么保证可靠性呢？

这里就得看QUIC协议了，QUIC协议属于OSI模型的会话层，其在UDP的之上把 TCP 的那一套连接管理、拥塞窗口、流量控制等特性“搬”了过来，“去其糟粕，取其精华”，打造出了一个全新的可靠传输协议，可以认为是“新时代的 TCP”。并且其引入了类似 HTTP/2 的“流”和“多路复用”，相当于将这类操作下移减轻HTTP/3的负担。

结合上面所述，所以HTTP/3具有以下特点：

- 基于QUIC和UDP，不需要握手挥手，优化慢启动，传输速度快
- 由于流管理被“下放”到了 QUIC，所以 HTTP/3 里帧的结构更简单
- 完全解决了“队头阻塞”问题
- QUIC基于不透明ID，支持连接迁移，优化弱网、重建连接等问题



## 参考文章

- [一文读懂HTTP/2特性](https://zhuanlan.zhihu.com/p/26559480)
- [透视HTTP协议](https://time.geekbang.org/column/intro/189)

